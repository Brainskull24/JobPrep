### C vs C++ vs Java vs Python vs JavaScript
![Screenshot 2025-09-14 at 5.29.48 PM.png](Screenshot%202025-09-14%20at%205.29.48%E2%80%AFPM.png)

### Working of JVM
- JVM (Java Virtual Machine) runs Java applications as a run-time engine. 
- JVM is the one that calls the main method present in a Java code. 
- JVM is a part of JRE (Java Runtime Environment). 
- Java applications are called WORA (Write Once Run Anywhere). 
- This means a programmer can develop Java code on one system and expect it to run on any other Java-enabled system without any adjustments. 
- This is all possible because of the JVM. When we compile a .java file, .class files (containing byte-code) with the same class names present in the .java file are generated by the Java compiler. 
- This .class file goes through various steps when we run it. These steps together describe the whole JVM.

![Screenshot 2025-09-14 at 5.36.05 PM.png](Screenshot%202025-09-14%20at%205.36.05%E2%80%AFPM.png)

### JIT (Just-In-Time Compiler)

- Role in JVM → JIT is part of the Java Runtime Environment (JRE) that improves performance by compiling frequently used bytecode into native machine code at runtime.
- Why Needed → Interpreting bytecode repeatedly is slower; JIT reduces overhead by executing compiled native code directly.
- Optimizations → Performs runtime optimizations like register allocation, reducing memory access, and eliminating common sub-expressions.
- Trade-off → More optimization = better performance, but also higher compilation overhead (time & memory).
- Execution Flow → Activated when methods are invoked; once compiled, JVM directly uses native code instead of interpreting bytecode repeatedly.

![Screenshot 2025-09-14 at 5.38.00 PM.png](Screenshot%202025-09-14%20at%205.38.00%E2%80%AFPM.png)

### Byte Code VS Machine Code

#### Bytecode
- Intermediate code between source code and machine code.
- Generated after compiling Java source code.
- Executed by the JVM (Java Virtual Machine), not directly by CPU.
- Platform-independent (portable) → same bytecode runs on any system with JVM.
- Needs interpretation/JIT compilation to become machine code.

#### Machine Code
- Final binary instructions (0s & 1s) directly executed by the CPU.
- Lowest-level representation of code.
- Obtained after JIT compilation or interpretation.
- Platform-dependent (specific to the processor architecture).
- Fastest to execute since CPU understands it directly.

### Data Types in Java
![Screenshot 2025-09-14 at 5.43.05 PM.png](Screenshot%202025-09-14%20at%205.43.05%E2%80%AFPM.png)

#### Primitive Data Types: 
These are the basic building blocks that store simple values directly in memory. 
Examples of primitive data types are:

- boolean
- char
- byte
- short
- int
- long
- float
- double

Note: The Boolean with uppercase B is a wrapper class for the primitive boolean type.

#### Non-Primitive Data Types (Object Types): 
These are reference types that store memory addresses of objects. 
Examples of Non-primitive data types are:

- String
- Array
- Class
- Interface
- Object

![Screenshot 2025-09-14 at 5.47.35 PM.png](Screenshot%202025-09-14%20at%205.47.35%E2%80%AFPM.png)

![Screenshot 2025-09-14 at 5.57.15 PM.png](Screenshot%202025-09-14%20at%205.57.15%E2%80%AFPM.png)

### Instance Variables VS Static Variables

**1. Copy of Variables** 
- Instance Variable → Each object has its own copy.
- Static Variable → Only one copy is shared by all objects of the class.

    ```
    class Student {
        String name;              // Instance Variable
        static String college = "ABC College"; // Static Variable
    
        Student(String name) {
            this.name = name;
        }
    }
    
    public class Test1 {
    public static void main(String[] args) {
    Student s1 = new Student("Alice");
    Student s2 = new Student("Bob");
    
            // Instance variable → each has different 'name'
            System.out.println(s1.name); // Alice
            System.out.println(s2.name); // Bob
    
            // Static variable → shared across objects
            System.out.println(s1.college); // ABC College
            System.out.println(s2.college); // ABC College
        }
    }
    ```

**2. Changes in Variables**
- Instance Variable → Change in one object’s variable doesn’t affect others.
- Static Variable → Change reflects in all objects.

**3. How to Access**
- Instance Variable → Access using object reference.
- Static Variable → Access using class name (recommended).

**4. Lifetime**
- Instance Variable → Created when an object is created (new), destroyed when object is garbage collected.
- Static Variable → Created once when class is loaded, destroyed when program ends.

### Scanner vs BufferedReader

![Screenshot 2025-09-14 at 6.18.49 PM.png](Screenshot%202025-09-14%20at%206.18.49%E2%80%AFPM.png)

#### Quick Note
System.out.print() is a by default one of built-in methods 
which show method overloading by printing any type of data.

### Control Statements

#### Already Covered in codebase!

### Operators

#### Already Covered in codebase!

### Arrays in Java

Arrays class is a utility class in java.util package that extends Object.

#### Array Methods
Already Discussed!

### Regular Expressions
- A regular expression (regex) is a sequence of characters that defines a search pattern.
- Used for pattern matching, searching, replacing, validation of strings.
- In Java, regex is handled by the java.util.regex package, mainly through Pattern and Matcher classes.

![Screenshot 2025-09-15 at 12.04.58 AM.png](Screenshot%202025-09-15%20at%2012.04.58%E2%80%AFAM.png)

![Screenshot 2025-09-15 at 12.03.37 AM.png](Screenshot%202025-09-15%20at%2012.03.37%E2%80%AFAM.png)

### OOPS

#### Key Features of OOP in Java:
- Structures code into logical units (classes and objects)
- Keeps related data and methods together (encapsulation)
- Makes code modular, reusable and scalable
- Prevents unauthorized access to data
- Follows the DRY (Don’t Repeat Yourself) principle

**Advantage of OOPs**

- By using objects and classes, you can create reusable components, leading to less duplication and more efficient development.
- It provides a clear and logical structure, making the code easier to understand, maintain, and debug.
- OOP supports the DRY (Don't Repeat Yourself) principle.This principle encourages minimizing code repetition, leading to cleaner, more maintainable code. Common functionalities are placed in a single location and reused, reducing redundancy.
- By reusing existing code and creating modular components, OOP allows for quicker and more efficient application development.

**Disadvantages of OOPs**
- OOP has concepts like classes, objects, inheritance etc. For beginners, this can be confusing and takes time to learn.
- If we write a small program, using OOP can feel too heavy. We might have to write more code than needed just to follow the OOP structure.
- The code is divided into different classes and layers, so in this, finding and fixing bugs can sometimes take more time.
- OOP creates a lot of objects, so it can use more memory compared to simple programs written in a procedural way.

**Java is not Purely OOP Language:**

![Screenshot 2025-09-15 at 12.26.44 AM.png](Screenshot%202025-09-15%20at%2012.26.44%E2%80%AFAM.png)


#### **Components of OOPS** 
**Class:**
- A Class is a user-defined blueprint or prototype from which objects are created. 
- It represents the set of properties or methods that are common to all objects of one type.
  - Modifiers: A class can be public or have default access (Refer to this for details).
  - Class name: The class name should begin with the initial letter capitalized by convention.
  - Body: The class body is surrounded by braces, { }.

**Object:**
- An Object is a basic unit of Object-Oriented Programming that represents real-life entities.

**Abstraction:**
- Abstraction in Java is the process of hiding the implementation details and only showing the essential details or features to the user. 
- It allows to focus on what an object does rather than how it does it. 
- The unnecessary details are not displayed to the user.

Note: In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.

**Encapsulation:**
- Encapsulation is defined as the process of wrapping data and the methods into a single unit, typically a class. 
- It is the mechanism that binds together the code and the data. It manipulates. 
- Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield. 

**Inheritance:**
- Inheritance is an important pillar of OOP (Object-Oriented Programming). 
- It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. 
- We are achieving inheritance by using extends keyword.

**Polymorphism:**
- The word polymorphism means having many forms. 
- It comes from the Greek words poly (many) and morph (forms), this means one entity can take many forms.

**Types of Polymorphism:**
- Method Overloading
- Method Overriding

**1. Method Overloading:** 
- Also, known as compile-time polymorphism, is the concept of Polymorphism where more than one method share the same name with different signature(Parameters) in a class. 
- The return type of these methods can or cannot be same.

**2. Method Overriding:** 
- Also, known as run-time polymorphism, is the concept of Polymorphism where method in the child class has the same name, return-type and parameters as in parent class. 
- The child class provides the implementation in the method already written.

**Constructors**
- A constructor is a special block of code that is called when an object is created. 
- Its main job is to initialize the object, to set up its internal state, or to assign default values to its attributes. 
- This process happens automatically when we use the "new" keyword to create an object.

![Screenshot 2025-09-15 at 12.28.35 PM.png](Screenshot%202025-09-15%20at%2012.28.35%E2%80%AFPM.png)

**What happens when we don't use constructors:** 

**Without constructors:**
- Objects might have undefined or default values.
- Extra initialization methods would be required.
- Risk of improper object state

**Types of Constructors in Java**
- Default Constructor
- Parameterized Constructor
- Copy Constructor

**1. Default Constructor**
- A constructor with no parameters (created automatically if no other constructor is defined).
- Initializes objects with default values.
- Compiler inserts it if you don’t define any constructor.
- If any constructor is defined explicitly, compiler does not provide the default one.


```
class Student {
    int id;
    String name;
    // Compiler provides: Student() {}
}
```

**2. No-Argument Constructor**
- Explicitly written constructor without parameters.
- Used when you want to initialize values manually inside it.
- Different from default constructor (since this one is written by the programmer).

```
class Student {
    Student() {
        System.out.println("No-arg constructor called");
    }
}
```

**3. Parameterized Constructor**
- A constructor that takes arguments.
- Used to initialize objects with custom values at the time of creation.
- Provides flexibility in assigning values.

```
class Student {
    int id;
    String name;
    Student(int i, String n) {
        id = i;
        name = n;
    }
}
```
**4. Copy Constructor**
- A constructor that creates a new object as a copy of an existing object.
- Java does not provide it by default, but you can define it.
- Useful in cloning object state.

```
class Student {
    int id;
    String name;
    Student(Student s) { // Copy constructor
        id = s.id;
        name = s.name;
    }
}
```

**5. Constructor Overloading**
- Multiple constructors in the same class with different parameter lists.
- Helps in providing different ways of initializing objects.
- Achieved by changing number or type of arguments.
```
class Student {
    Student() {}
    Student(int i) {}
    Student(int i, String n) {}
}
```

**6. Private Constructor**
- Declared as private so that it cannot be accessed outside the class.
- Used in Singleton Design Pattern to restrict object creation.
- Only accessible within the same class.

```
class Singleton {
    private static Singleton obj = new Singleton();
    private Singleton() {}  // private constructor
    public static Singleton getInstance() {
        return obj;
    }
}
```

**Key Interview Notes**
- Default constructor → Added by compiler if no constructor is defined.
- No-arg constructor → Written explicitly by programmer (not auto).
- Parameterized constructor → Used for custom initialization.
- Copy constructor → Creates copy of another object (manual in Java).
- Overloaded constructor → Multiple constructors in one class.
- Private constructor → Restricts object creation (used in Singleton).


### **Throwable Class in java**


- Superclass of all errors and exceptions in Java.

- Hierarchy:

``````
Object
    ↳ Throwable
        ↳ Error (serious issues, not recoverable, e.g., OutOfMemoryError)
        ↳ Exception (can be handled using try-catch)
            ↳ Checked Exceptions (IOException, SQLException)
            ↳ Unchecked Exceptions (RuntimeException, NullPointerException, etc.)
``````

**Important Methods of Throwable:**

![Screenshot 2025-09-15 at 3.10.10 PM.png](Screenshot%202025-09-15%20at%203.10.10%E2%80%AFPM.png)

### **Exception Handling**

- Exception handling in Java is an effective mechanism for managing runtime errors to ensure the application's regular flow is maintained. 
- Some Common examples of exceptions include ClassNotFoundException, IOException, SQLException, RemoteException, etc.
- By handling these exceptions, Java enables developers to create robust and fault-tolerant applications.

![Screenshot 2025-09-15 at 3.22.05 PM.png](Screenshot%202025-09-15%20at%203.22.05%E2%80%AFPM.png)

**Major Reasons Why an Exception Occurs**

- Invalid user input
- Device failure
- Loss of network connection
- Physical limitations (out-of-disk memory)
- Code errors
- Out of bound
- Null reference
- Type mismatch
- Opening an unavailable file
- Database errors
- Arithmetic errors

**How Does JVM Handle an Exception?**
- When an Exception occurs, the JVM creates an exception object containing the error name, description and program state. 
- Creating the exception object and handling it in the run-time system is called throwing an exception. 
- There might be a list of the methods that had been called to get to the method where an exception occurred. 
- This ordered list of methods is called Call stack. 
- Now the following procedure will happen:
    - The run-time system searches the call stack for an exception handler
    - It starts searching from the method where the exception occurred and proceeds backward through the call stack.
    - If a handler is found, the exception is passed to it.
    - If no handler is found, the default exception handler terminates the program and prints the stack trace.

![Screenshot 2025-09-15 at 3.27.45 PM.png](Screenshot%202025-09-15%20at%203.27.45%E2%80%AFPM.png)

**Errors VS Exception**

![Screenshot 2025-09-15 at 3.28.56 PM.png](Screenshot%202025-09-15%20at%203.28.56%E2%80%AFPM.png)

**Types of Exceptions**

![Screenshot 2025-09-15 at 3.25.56 PM.png](Screenshot%202025-09-15%20at%203.25.56%E2%80%AFPM.png)

**Built-in exceptions:**

- ArithmeticException: It is thrown when an exceptional condition has occurred in an arithmetic operation.
- ArrayIndexOutOfBoundsException: It is thrown to indicate that an array has been accessed with an illegal index. 
- ClassNotFoundException: This Exception is raised when we try to access a class whose definition is not found.
- FileNotFoundException: This Exception is raised when a file is not accessible or does not open.
- IOException: It is thrown when an input-output operation failed or interrupted.
- InterruptedException: It is thrown when a thread is waiting, sleeping, or doing some processing, and it is interrupted.
- NoSuchFieldException: It is thrown when a class does not contain the field (or variable) specified.
- NoSuchMethodException: It is thrown when accessing a method that is not found.
- NullPointerException: This exception is raised when referring to the members of a null object. Null represents nothing.
- NumberFormatException: This exception is raised when a method could not convert a string into a numeric format.
- RuntimeException: This represents an exception that occurs during runtime.
- StringIndexOutOfBoundsException: It is thrown by String class methods to indicate that an index is either negative or greater than the size of the string.
- IllegalArgumentException : This exception will throw the error or error statement when the method receives an argument which is not accurately fit to the given relation or condition.  
- IllegalStateException : This exception will throw an error or error message when the method is not accessed for the particular operation in the application.

![Screenshot 2025-09-15 at 4.54.21 PM.png](Screenshot%202025-09-15%20at%204.54.21%E2%80%AFPM.png)

**Exception Handling Keywords**

- try → Block of code to monitor for exceptions.
- catch → Handles the exception.
- finally → Always executes (cleanup code).
- throw → Used to throw an exception explicitly.
- throws → Declares exceptions a method might throw.

**Internal working of try-catch Block**
- Java Virtual Machine starts executing the code inside the try block.
- If an exception occurs, the remaining code in the try block is skipped, and the JVM starts looking for the matching catch block.
- If a matching catch block is found, the code in that block is executed.
- After the catch block, control moves to the finally block (if present).
- If no matching catch block is found the exception is passed to the JVM default exception handler.
- The final block is executed after the try catch block. regardless of whether an exception occurs or not.

**Exception Handling Tips**

- ✅ Catch specific exceptions instead of generic Exception.
- ✅ Always clean resources in finally or use try-with-resources.
- ✅ Don’t swallow exceptions silently (catch (Exception e) {}).
- ✅ Use custom exceptions for meaningful error handling.
- ✅ Avoid overusing checked exceptions (makes code messy).

**final, finally, finalize in Java:**

- final (Keyword)
    - Used with variables, methods, classes.
    - Variable → makes it constant (cannot reassign).
    - Method → cannot be overridden.
    - Class → cannot be inherited.

```dtd
final class Parent {}
class Child extends Parent {} // ❌ Compile-time error

final int x = 10;
x = 20; // ❌ Cannot reassign

class A {
    final void show() {}
}

class B extends A {
    void show() {} // ❌ Cannot override
}
```
👉 Interview Tip: final is a modifier, not related to exception handling.

- finally (Block)
    - Used in exception handling.
    - Ensures code always executes (like cleanup).
    - Runs whether exception occurs or not.
    - Skipped only if JVM shuts down (System.exit()).

```dtd
try {
    int a = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception caught");
} finally {
    System.out.println("Finally always runs");
}
```


- **finalize() (Method in Object class):**
    - Called by Garbage Collector (GC) before destroying an object.
    - Rarely used (unpredictable).
    - Declared as: protected void finalize().

```dtd
class Test {
    protected void finalize() {
        System.out.println("Finalize called before GC");
    }
    public static void main(String[] args) {
        Test t = new Test();
        t = null;
        System.gc(); // Suggest GC to run
    }
}
```
👉 Interview Tip: finalize() is deprecated since Java 9 (not reliable for cleanup, use AutoCloseable instead).

### **Chained Exceptions in Java**

- Introduced in JDK 1.4.
- Allows linking one exception with another (cause of failure).
- Methods:
    - initCause(Throwable cause) → attach original cause.
    - getCause() → retrieve original cause.

```dtd
try {
    try {
        int a = 10 / 0;
    } catch (ArithmeticException e) {
        throw new Exception("Exception in outer block").initCause(e);
    }
} catch (Exception e) {
    System.out.println("Caught: " + e);
    System.out.println("Original Cause: " + e.getCause());
}
```

👉 Output:

```dtd
Caught: java.lang.Exception: Exception in outer block
Original Cause: java.lang.ArithmeticException: / by zero
```
👉 Interview Tip: Useful in logging root cause of exceptions (e.g., database → service → UI).

### **NullPointerException (NPE)**

- Most common runtime exception in Java.
- Thrown when you try to use null as an object reference.

**Common Causes:**

````
String s = null;
System.out.println(s.length()); // NPE

int[] arr = null;
System.out.println(arr[0]); // NPE

Object obj = null;
obj.toString(); // NPE
````

**How to Prevent:**

- ✅ Use Objects.requireNonNull(obj)
- ✅ Use Optional<T> (Java 8+)
- ✅ Always check if(obj != null)
- ✅ Initialize variables properly

````
String str = null;
System.out.println(Optional.ofNullable(str).orElse("Default")); // Default
````
👉 Interview Tip: Asked frequently → "How do you prevent NPE in Java 8?"

### **Exception Handling with Method Overriding**
- **Unchecked Exceptions (Runtime)**
  - No restriction. Subclass can throw or not throw.

    ````
    class Parent {
        void show() { throw new RuntimeException(); }
    }
    
    class Child extends Parent {
        void show() { } // ✅ allowed
    }
    ````

- **Checked Exceptions**
  - If parent method throws checked exception, child:
    - Can throw the same exception
    - Can throw subclass of that exception
    - Cannot throw broader exception

    ```dtd
    class Parent {
        void read() throws IOException {}
    }
    
    class Child extends Parent {
        void read() throws FileNotFoundException {} // ✅ (subclass)
        // void read() throws Exception {} ❌ Not allowed
    }
    ```


- **If parent does not throw exception**
  - Child cannot throw checked exceptions.
  - Can throw unchecked exceptions.

    ```dtd
    class Parent {
        void show() {}
    }
    class Child extends Parent {
        void show() throws IOException {} // ❌ Not allowed
    }
    ```
👉 Interview Tip: This is asked as "Can overridden method throw different exceptions?"